# synchronized 和 ReentrantLock 的区别

共通

* 都是可重入锁

  自己可以再次获取自己的内部锁。

  比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。

synchronized

* 关键字
* 依赖于 JVM 实现

ReentrantLock

* 类

* 依赖于 API 实现（需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成）

* 增加了一些高级功能

  1)等待可中断；

  2)可实现公平锁；

  3)可实现选择性通知（锁可以绑定多个条件）
